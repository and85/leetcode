1. if we have an array of positive integers, and want to mark visited elements in place without extra space, 
we could just change a sign for touched elements to negative

2. take your own markers to the interview, different colors

3. Ингда чтобы проверить, что какая-то функция возвращает true или false, и сложно проверить одно условие, например true, можно проверить только условия когда результат false а в
остальных случаях возвращать true. Пример: https://leetcode.com/problems/rectangle-overlap/

4. Чтобы поменять направление вектора, можно увеличивать направление как число и делить на модуль 4, чтобы не было переполнения и всегда получать адекватное направление:
https://leetcode.com/problems/robot-bounded-in-circle/solution/

5. Check number is a perfect square:
private bool IsPerfectSquare(double x)
        {
            double sr = Math.Sqrt(x);

            return ((sr - Math.Floor(sr)) == 0);
        }

6. Array.Sort is not stable sorting. If we want to have a stable sorting, use Lynq OrderBy or create stabilyzing comparer:
https://leetcode.com/problems/reorder-data-in-log-files/discuss/939487/c-two-approaches

7. to avoid integer overflow errors, sometimes we should use target + 1 instead of int.Max
https://leetcode.com/problems/coin-change/submissions/

8. C# List contains indexer which allows O(1) access because of the internal implementation as array. e.g. we can write something
like:
var list = new List<List<int>>();
...
list[1].Add

However Insert(index, element) or list.ElementAt(index) will be O(n), because those methods is common for Enumerable and and a collection represented by enumerable may not have an indexer.

9. Arrays
Binary trees can also be stored in breadth-first order as an implicit data structure in arrays, and if the tree is a complete binary tree, this method wastes no space. In this compact arrangement, if a node has an index i, its children are found at indices {\displaystyle 2i+1}2i+1 (for the left child) and {\displaystyle 2i+2}2i+2 (for the right), while its parent (if any) is found at index {\displaystyle \left\lfloor {\frac {i-1}{2}}\right\rfloor }\left\lfloor {\frac {i-1}{2}}\right\rfloor  (assuming the root has index zero).

10. The best-known rule for traversing mazes is the wall follower, also known as either the left-hand rule or the right-hand rule. 
11. C# List class contains BinarySearch methid which works for sorted lists
12. C# Random.Next(minValue, maxValue), upper bound is exclusive https://leetcode.com/problems/insert-delete-getrandom-o1/solution/
13. We can remove an element from a list in O(1) time, just by swapping the element we want to remove with the last one: https://leetcode.com/problems/insert-delete-getrandom-o1/solution/
14. C# OrderedDictionary is very wierd collection, e.g. it's not generic and it's not really intuitive how to use it properly. But similar functionality could be achieved by using a 
simple combination of Queue/Stack together with Dictionary: https://leetcode.com/problems/first-unique-number/submissions/

15. Dijkstra algorithm doesn't work correctly when there are negative weights of edges (it could give a wrong answer in such a case): https://www.youtube.com/watch?v=XB4MIexjvY0&ab_channel=AbdulBari
16.Bellman-Ford works for graphs with nagitive edges, works for graphs with cycles, but fails for graphs with cycles with negative edges. But it's possible to detect if there is a cycle with negative edge. 
(at the last step, none vertixes have to be relaxed, and if there are, we have faced the cycle)
https://www.youtube.com/watch?v=FtN3BYH2Zes&ab_channel=AbdulBari